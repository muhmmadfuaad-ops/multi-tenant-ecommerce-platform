generator client {
  provider      = "prisma-client"
  output        = "../src/prisma/generated"
  engineType    = "client"
  moduleFormat  = "cjs"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
}

enum Role {
  ADMIN
  USER
}

enum ProductStatus {
  DRAFT
  PUBLISHED
  OUT_OF_STOCK
  ARCHIVED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum SessionStatus {
  ACTIVE
  LOGGED_OUT
  REVOKED
  EXPIRED
}

enum OtpType {
  PHONE
  EMAIL
}

enum DeliveryStatus {
  DRAFT
  PENDING
  DELIVERED
  FAILED
}

enum rating {
  ONE
  TWO
  THREE
  FOUR
  FIVE
}
///////////////////////
// MODELS
///////////////////////

// Multi-tenant container
model Tenant {
  id     String  @id @default(uuid(7)) @db.Uuid
  name   String
  domain String? @unique

  users    User[]
  products Product[]
  orders   Order[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
}

// Users
model User {
  id           String  @id @default(uuid(7)) @db.Uuid
  email        String?
  phone        String?
  name         String?
  passwordHash String?
  role         Role    @default(USER)
  profileImage String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @db.Uuid
  favouriteProducts Product[] @relation("Favourites")

  products  Product[]
  orders    Order[]
  addresses Address[]
  sessions  Session[]
  otps      OTP[]
  reviews   Review[]
  notifications Notification[]

  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // prevent duplicate users inside the SAME tenant
  @@unique([email, tenantId])
  @@unique([phone, tenantId])
}

// OTP for email/phone verification
model OTP {
  id        String   @id @default(uuid(7)) @db.Uuid
  code      String
  type      OtpType
  verified  Boolean  @default(false)
  expiresAt DateTime

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now())
  usedAt    DateTime?
}

// User login sessions (refresh tokens + tracking)
model Session {
  id String @id @default(uuid(7)) @db.Uuid

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid

  refreshToken String
  status       SessionStatus @default(ACTIVE)
  expiresAt    DateTime

  // Tracking / metadata
  userAgent String?
  ipAddress String?
  ipMeta    Json? // JSONB storing geo lookup, user agent, device info etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

// Products listed by sellers
model Product {
  id          String        @id @default(cuid(2))
  name        String
  description String?
  price       Float
  status      ProductStatus @default(DRAFT)
  stock       Int           @default(0)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @db.Uuid
  seller   User   @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  sellerId String @db.Uuid
  reviews  Review[]

  likers     User[] @relation("Favourites")
  orders     OrderItem[]
  categories Category[]  @relation("ProductCategories")

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // prevent duplicate product names inside SAME tenant
  @@unique([name, tenantId])
}

// Orders placed by buyers
model Order {
  id            String        @id @default(cuid(2))
  totalAmount   Float
  status        OrderStatus   @default(PENDING)
  paymentStatus PaymentStatus @default(PENDING)

  buyer    User   @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  buyerId  String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @db.Uuid

  items OrderItem[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
}

// Individual products in an order
model OrderItem {
  id        String  @id @default(cuid(2))
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String
  quantity  Int
  price     Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Optional: Addresses for users
model Address {
  id      String  @id @default(cuid(2))
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String  @db.Uuid
  line1   String
  line2   String?
  city    String
  state   String
  postal  String
  country String

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
}

// Optional: Product categories
model Category {
  id   String @id @default(cuid(2))
  name String

  products Product[] @relation("ProductCategories")

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
}

model Review {
  id        String  @id @default(cuid(2))
  rating    Int
  comment   String?
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String  @db.Uuid
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Notification {
  id        String   @id @default(cuid(2))
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  title     String
  message   String
  read      Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Message {
  id        String   @id @default(cuid(2))
  sender     User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId   String   @db.Uuid

  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId String   @db.Uuid
  content   String
  deliveryStatus DeliveryStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// model Favourite {
//   id        String   @id @default(cuid())
//
//   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   userId    String   @db.Uuid
//
//   product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
//   productId String
//
//   createdAt DateTime @default(now())
//
//   @@unique([userId, productId])
// }
